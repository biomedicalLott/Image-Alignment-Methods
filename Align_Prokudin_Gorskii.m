%%All contents herein were created by Robert Lott for Robotics Algorithms
%% November 20th 2021
% % The assignment is to align the Prokudin Gorski image
% collection using Sum Of Square Differences, 
% Normalized Cross Correlation, and
% RANSAC 

function Align_Prokudin_Gorskii(filename, saveImportedImage, saveFirstAlign,...
    saveSecondAlign, saveThirdAlign)
%MAIN Takes a black and white image of a certain sort that contains all 3
%channels separated along the same 2D matrix and returns a single 3D image
%matrix as a jpeg. Then, 3 alignment methods are tested to demonstrate
%their differences. You may choose whether to save any one of the images
%generated by setting the corresponding save to "true" Otherwise you may
%leave them blank and simply give the filename, as a string. Following this
%e.g. - main('image1.jpg') is as valid as
%main('image1.jpg',false,false,false,false)
if ~exist('saveMain','var')
    saveImportedImage = false;
end
if ~exist('saveFirst','var')
    saveFirstAlign = false;
end
if ~exist('saveSecond','var')
    saveSecondAlign = false;
end
if ~exist('saveThird','var')
    saveThirdAlign = false;
end
%min/max intensity threshold for hopefully eliminating pure white and
%black edges
intensityThreshold = [80,200];
image1 = importdata(filename);
[~,imageName] = fileparts(filename);

%remove white and black images from the image file
image1edit = removeEdges(image1, intensityThreshold(1), intensityThreshold(2));
%now split the image into thirds using checks to ensure only the black edge
%is used as the actual edge if possibble
[r,g,b] = splitImageIntoThirds(image1edit);
%then recombine aaaaand 
rgbImage(:,:,1) = b;
rgbImage(:,:,2) = g;
rgbImage(:,:,3) = r;
figure(1)
imshow(rgbImage);
title('no alignment')
% %write the image!
im_align_SSD(rgbImage, filename,saveFirstAlign);
im_align_NCC(rgbImage, filename,saveSecondAlign);
im_align_RANSAC(rgbImage, filename,saveThirdAlign);

if saveImportedImage 
imwrite(rgbImage, strcat([imageName,'-color.jpg']));
end


function [red, green, blue]= splitImageIntoThirds(rawImage)
%% splitImageIntoThirds
%%Takes an image and splits it into 3 images in the R, G, and B spectrums
%%the resulting image will attempt to have its bars removed and be scaled
%%down to fit more nicely together.
%%Input - rawImage is an image file containing R, G, and B separated
%%images
%%Output -
%%red   contains red channel
%%green   contains green channel
%%blue   contains blue channel

imageSize = size(rawImage);
%split the images into thirds (rounded for indexing)
third = round(imageSize(1)/3);
%grab a line in the middle that I'll be used to judge against
middleLine = rawImage(:,100);

%make a copy of the image
copy = rawImage;
%a threshold for the closest value to "black" in the split images.
threshold = 20;
%split red, green, and blue channels from the image
red = split();
green = split();
blue = split();
%now, remove the edges, although given that only the red edge should have
%latent nastyness, i'm leaving it as the only image removing very bright
%but not max intensity spectrum light
red = removeEdges(red, 20, 200);
blue = removeEdges(blue, 20, 240);
green = removeEdges(green, 20, 240);
%and finally, make all images identical in size by using the minimum values
sizes = [size(red); size(green); size(blue)];
imageHeightMin = min(sizes(:,1));
imageWidthMin = min(sizes(:,2));

red = red(1:imageHeightMin,1:imageWidthMin);
green = green(1:imageHeightMin,1:imageWidthMin);
blue = blue(1:imageHeightMin,1:imageWidthMin);


    function section = split()
        %%function finds the lowest value around the 1/3 mark and uses that
        %%with a simple threshold to find where to split the image and lose
        %%the unwanted info

        startSplit = 0;
        endSplit = 0;
        %Check 20 points around the minimum value
        bottom = third-10;
        top = third+10;
        %ensure that the top doesn't exceed the dimensions of the line
        if(top > length(middleLine))
            top = length(middleLine);
            if(bottom > top)
                bottom = top-5;
            end
        end
        %take in the minimum value, the index being the more important
        %part here.
        [minVal,index] = min(middleLine(bottom:top));
        index = bottom+index;
        if(index > length(middleLine))
            index = length(middleLine)
        end
        %double check to make sure the endpoint i'm splitting a won't
        %exceed the maximum index
        endSplit = index+3;
        if(endSplit > top)
            endSplit = top;
        end
        %now, check within a range to see if perhaps other values
        %still fall along those black lines
        for i = [index:endSplit]
            if(middleLine(i) < threshold)
                endSplit = i;
            end
        end
        startSplit = index-3;
        for i = [startSplit:index]
            if(middleLine(i) < threshold)
                startSplit = i;
                break;
            end
        end
        %separate out the section i want, modify the copy, and finally,
        %modify the middle line
        section  = copy(1:startSplit,:);
        copy = copy(endSplit:end,:);
        middleLine = middleLine(endSplit:end,:);
    end
end
function editedImage = removeEdges(rawImage, lowerThresh, upperThresh)
%%REMOVEEDGES - retains only the values of the 2D image from a threshold, hopefully
%%eliminating the edges of the image files.

imageSize = size(rawImage);

%calculate the cutoffs on each edge
leftSideCutoff= 1;
for i = 1:imageSize(2)
    if(rawImage(100,i) >  lowerThresh && rawImage(100,i) < upperThresh)
        leftSideCutoff = i-1;
        break;
    end
end
rightSideCutoff= imageSize(2);
for i = [imageSize(2):-1:1]
    if(rawImage(100,i) >  lowerThresh && rawImage(100,i) < upperThresh)
        rightSideCutoff = i+1;
        break;
    end
end
topSideCutoff = 1;
for i = 1: imageSize(1)
    if(rawImage(i,100) >  lowerThresh && rawImage(i,100) < upperThresh)
        topSideCutoff = i-1;
        break;
    end
end
bottomSideCutoff = imageSize(1);
for i = [imageSize(1):-1:1]
    if(rawImage(i,100) >  lowerThresh && rawImage(i,100) < upperThresh)
        bottomSideCutoff = i+1;
        break;
    end
end



%make sure that the cutoffs actually happen within the bounds of the image,
%this allows for "perfect" images to not cause it to break.
if leftSideCutoff < 1
    leftSideCutoff = 10;
end
if rightSideCutoff >imageSize(2)
    rightSideCutoff = imageSize(2);
end
if topSideCutoff < 1
    topSideCutoff = 1;
end
if bottomSideCutoff >imageSize(1)
    bottomSideCutoff = imageSize(1);
end
%output edited image.
editedImage = rawImage(topSideCutoff:bottomSideCutoff,leftSideCutoff:rightSideCutoff);
end

end

